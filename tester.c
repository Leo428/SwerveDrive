#pragma config(UART_Usage, UART2, uartNotUsed, baudRate4800, IOPins, None, None)
#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    zC,             sensorAccelerometer)
#pragma config(Sensor, in2,    xC,             sensorAccelerometer)
#pragma config(Sensor, in3,    yC,             sensorAccelerometer)
#pragma config(Sensor, I2C_1,  backLeftEncoder, sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_2,  frontLeftEncoder, sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_3,  frontRightEncoder, sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_4,  backRightEncoder, sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Motor,  port1,           backLeftControl, tmotorVex393_HBridge, openLoop, reversed, encoderPort, I2C_1)
#pragma config(Motor,  port3,           backLeftDrive, tmotorVex393_MC29, openLoop, driveLeft)
#pragma config(Motor,  port4,           frontLeftControl, tmotorVex393_MC29, openLoop, encoderPort, I2C_2)
#pragma config(Motor,  port5,           frontLeftDrive, tmotorVex393_MC29, openLoop, driveLeft)
#pragma config(Motor,  port6,           frontRightControl, tmotorVex393_MC29, openLoop, encoderPort, I2C_3)
#pragma config(Motor,  port7,           frontRightDrive, tmotorVex393_MC29, openLoop, reversed, driveRight)
#pragma config(Motor,  port9,           backRightDrive, tmotorVex393_MC29, openLoop, reversed, driveRight)
#pragma config(Motor,  port10,          backRightControl, tmotorVex393_HBridge, openLoop, encoderPort, I2C_4)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

void init(){
	resetMotorEncoder(motor[frontLeftControl]);
	resetMotorEncoder(motor[frontRightControl]);
	resetMotorEncoder(motor[backLeftControl]);
	resetMotorEncoder(motor[backRightControl]);
}
void initValues(){
	if(vexRT[Btn7U] == 1){
		motor[frontLeftControl] = vexRT[Ch1];
		resetMotorEncoder(motor[frontLeftControl]);
	}
	if(vexRT[Btn7R] == 1){
		motor[frontRightControl] = vexRT[Ch1];
		resetMotorEncoder(motor[frontRightControl]);
	}
	if(vexRT[Btn7L] == 1){
		motor[backLeftControl] = vexRT[Ch1];
		resetMotorEncoder(motor[backLeftControl]);
	}
	if(vexRT[Btn7D] == 1){
		motor[backRightControl] = vexRT[Ch1];
		resetMotorEncoder(motor[backRightControl]);
	}
}

void tankDrive(){
	if(vexRT[Btn5U] == 1){
		motor[frontLeftDrive] = 127;
		motor[backLeftDrive] = 127;
	}
	if(vexRT[Btn5D] == 1){
		motor[frontLeftDrive] = -127;
		motor[backLeftDrive] = -127;
	}
	if(vexRT[Btn6U] == 1){
		motor[frontRightDrive] = 127;
		motor[backRightDrive] = 127;
	}
	if(vexRT[Btn6D] == 1){
		motor[frontRightDrive] = -127;
		motor[backRightDrive] = -127;
	}
}

void autoAdjust(short master, short slave){
		setMotorTarget(motor[slave], nMotorEncoder[master], 50, true);
		waitUntilMotorStop(motor[slave]);
}

void syncMotor(short master, short slave1, short slave2, short slave3){
	//motor[master] = vexRT[Ch4];
	int masterValue = nMotorEncoder[master];
	int slaveSumValue = nMotorEncoder[slave1] + nMotorEncoder[slave2] + nMotorEncoder[slave3];
	if(masterValue * 3 != slaveSumValue){ // if they are different values
		autoAdjust(master, slave1);
		autoAdjust(master, slave2);
		autoAdjust(master, slave3);
	}
}

void normalDrive(){
	if(vexRT[Btn7U] == 0 && vexRT[Btn7D] == 0 && vexRT[Btn7L] == 0 && vexRT[Btn7R] ==0){
		syncMotor(frontRightControl,frontLeftControl,backLeftControl,backRightControl);
		motor[backRightDrive] = vexRT[Ch2];
		motor[backLeftDrive] = vexRT[Ch2];
		motor[frontRightDrive] = vexRT[Ch2];
		motor[frontLeftDrive] = vexRT[Ch2];
	}
}

task main(){
	init();
	setMotorTarget(motor[frontRightControl], 100, 70, true);
	waitUntilMotorStop(motor[frontRightControl]);
	//while(true){
	//	tankDrive();
	//	initValues();
	//	normalDrive();
	//}
}
